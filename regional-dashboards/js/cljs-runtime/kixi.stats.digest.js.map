{"version":3,"sources":["kixi/stats/digest.cljc"],"mappings":";AAiCA,AAAA,AAAMA,AACHC,AAAGC;AADN,AAEE;;;AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;;AAAAC;AAAA,AAAA,AAAAC,AAAAD;AAAA,AAAAE,AAAAD,AAAA,AAAA,AAgBKI;AAhBL,AAAAH,AAAAD,AAAA,AAAA,AAgBOK;AAhBP,AAAAJ,AAAAD,AAAA,AAAA,AAgBUM;AAhBV,AAAAL,AAAAD,AAAA,AAAA,AAgBaO;AAhBb,AAAAN,AAAAD,AAAA,AAAA,AAgBiBQ;AAhBjB,AAAAP,AAAAD,AAAA,AAAA,AAgBqBS;AAhBrB,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAiBOL,AACIC,AACAC,AACAG,AACAF,AACAC;;AAtBXN,AAEmFS;AAFnF,AAAA,AAAAR,AAAAD;AAAA,AAAAD,AAAAE,AAAA,AAAA,AAEaC;AAFb,AAAAH,AAAAE,AAAA,AAAA,AAEuBE;AAFvB,AAAAJ,AAAAE,AAAA,AAAA,AAEkCG;AAFlC,AAAAL,AAAAE,AAAA,AAAA,AAE6CI;AAF7C,AAAAN,AAAAE,AAAA,AAAA,AAEyDK;AAFzD,AAAAP,AAAAE,AAAA,AAAA,AAEqEM;AAFrEN,AAE8EO;AAF9E,AAGG,AAAME,AAAE,AAACf,AAAAA,AAAAA,AAAGc,AAAAA;AACNE,AAAE,AAACf,AAAAA,AAAAA,AAAGa,AAAAA;AADZ,AAEE,AAAI,AAAI,AAAA,AAAMC,AAAG,AAAA,AAAMC;AACrBH;;AACA,AAAME,AAAYA;AACZC,AAAYA;AACZC,AAAI,AAAA,AAAKV;AACTW,AAAI,AAAGV,AAAG,AAAG,AAAGO,AAAEP,AAAIS;AACtBE,AAAI,AAAGV,AAAG,AAAG,AAAGO,AAAEP,AAAIQ;AAJ5B,AAAA,AAKGA,AAAGC,AAAIC,AACP,AAAGT,AAAK,AAAG,AAAGK,AAAEG,AAAK,AAAGH,AAAEP,AAC1B,AAAGG,AAAK,AAAG,AAAGK,AAAEG,AAAK,AAAGH,AAAEP,AAC1B,AAAGG,AAAK,AAAG,AAAGG,AAAEG,AAAK,AAAGF,AAAEP;;;AAfpCJ,AAEmFS;;;;;AAFnFT;;AAAAA,AAEmFS","names":["kixi.stats.digest/sum-squares","fx","fy","p__36214","vec__36219","cljs.core.nth","p__36213","vec__36215","c","mx","my","ssx","ssy","ssxy","acc","e","x","y","c'","mx'","my'"],"sourcesContent":["(ns kixi.stats.digest\n  (:require [kixi.stats.distribution])\n  #?(:clj (:import [com.tdunning.math.stats TDigest])))\n\n#?(:clj\n   (defn ^:no-doc nan->nil [n]\n     (when-not (or (.isNaN n) (.isInfinite n)) n)))\n\n#?(:clj\n   (defn t-digest\n     \"Return a reducing function which uses the t-digest to summarize a seq\"\n     [{:keys [compression] :or {compression 100} :as opts}]\n     (fn\n       ([] (TDigest/createAvlTreeDigest compression))\n       ([^TDigest digest x]\n        (when (number? x) (.add digest x 1))\n        digest)\n       ([^TDigest digest]\n        (reify\n          clojure.lang.Counted\n          (count [_]\n            (.size digest))\n          kixi.stats.protocols.PBounded\n          (minimum [_]\n            (nan->nil (.getMin digest)))\n          (maximum [_]\n            (nan->nil (.getMax digest)))\n          kixi.stats.protocols.PQuantile\n          (cdf [_ x]\n            (nan->nil (.cdf digest x)))\n          (quantile [_ q]\n            (nan->nil (.quantile digest q))))))))\n\n(defn sum-squares\n  [fx fy]\n  (fn\n    ([] [0.0 0.0 0.0 0.0 0.0 0.0])\n    ([[^double c ^double mx ^double my ^double ssx ^double ssy ^double ssxy :as acc] e]\n     (let [x (fx e)\n           y (fy e)]\n       (if (or (nil? x) (nil? y))\n         acc\n         (let [x   (double x)\n               y   (double y)\n               c'  (inc c)\n               mx' (+ mx (/ (- x mx) c'))\n               my' (+ my (/ (- y my) c'))]\n           [c' mx' my'\n            (+ ssx  (* (- x mx') (- x mx)))\n            (+ ssy  (* (- y my') (- y my)))\n            (+ ssxy (* (- x mx') (- y my)))]))))\n    ([[c mx my ssx ssy ssxy]]\n     {:n c\n      :x-bar mx\n      :y-bar my\n      :ss-xy ssxy\n      :ss-x  ssx\n      :ss-y  ssy})))\n"]}
{"version":3,"sources":["testdouble/cljs/csv.cljs"],"mappings":"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","names":["testdouble.cljs.csv/escape-quotes","s","clojure.string/replace","testdouble.cljs.csv/wrap-in-quotes","testdouble.cljs.csv/separate","data","separator","quote?","clojure.string.join","G__29338","cljs.core.map","cljs.core/str","testdouble.cljs.csv/write-data","newline","p1__29339#","testdouble.cljs.csv/newlines","testdouble.cljs.csv/newline-error-message","cljs.core/keys","var_args","args__4777__auto__","len__4771__auto__","i__4772__auto__","argseq__4778__auto__","cljs.core/IndexedSeq","testdouble.cljs.csv/write-csv","seq29362","G__29363","cljs.core/first","cljs.core/next","self__4758__auto__","options","map__29364","cljs.core/--destructure-map","cljs.core.get","temp__5733__auto__","newline-char","js/Error","p__29413","map__29420","testdouble.cljs.csv/-advance","chars","state","cljs.core.assoc","cljs.core/rest","p__29478","map__29479","testdouble.cljs.csv/-consume","char","cljs.core.update","p__29497","map__29498","testdouble.cljs.csv/-end-field","field-buffer","row","cljs.core.conj","testdouble.cljs.csv/-end-row","map__29505","cljs.core/conj","testdouble.cljs.csv/-init-read","cljs.core/seq","testdouble.cljs.csv/read-csv","seq29553","G__29554","map__29605","cljs.core/contains?","G__29648","map__29649","map__29811","in-quoted-field","cljs.core/not","cljs.core._EQ_","cljs.core.dissoc"],"sourcesContent":["(ns testdouble.cljs.csv\n  (:require [clojure.string :as str]))\n\n(defn- escape-quotes [s]\n  (str/replace s \"\\\"\" \"\\\"\\\"\"))\n\n(defn- wrap-in-quotes [s]\n  (str \"\\\"\" (escape-quotes s) \"\\\"\"))\n\n(defn- separate [data separator quote?]\n  (str/join separator\n            (cond->> data\n              :always (map str)\n              quote? (map wrap-in-quotes))))\n\n(defn- write-data [data separator newline quote?]\n  (str/join newline (map #(separate % separator quote?) data)))\n\n(def ^:private newlines\n  {:lf \"\\n\" :cr+lf \"\\r\\n\"})\n\n(def ^:private newline-error-message\n  (str \":newline must be one of [\" (str/join \",\" (keys newlines)) \"]\"))\n\n(defn write-csv\n  \"Writes data to String in CSV-format.\n  Accepts the following options:\n  :separator - field separator\n               (default ,)\n  :newline   - line separator\n               (accepts :lf or :cr+lf)\n               (default :lf)\n  :quote?    - wrap in quotes\n               (default false)\"\n\n  {:arglists '([data] [data & options]) :added \"0.1.0\"}\n  [data & options]\n  (let [{:keys [separator newline quote?] :or {separator \",\" newline :lf quote? false}} options]\n    (if-let [newline-char (get newlines newline)]\n      (write-data data\n                  separator\n                  newline-char\n                  quote?)\n      (throw (js/Error. newline-error-message)))))\n\n(defn- -advance\n  \"Move to the next character.\"\n  [{:keys [chars] :as state}]\n  (assoc state\n         :char  (first chars)\n         :chars (rest chars)))\n\n(defn- -consume\n  \"Append the current character onto the field. Advances.\"\n  [{:keys [char] :as state}]\n  (-> state\n      (update :field-buffer str char)\n      (-advance)))\n\n(defn- -end-field\n  \"Finalize the field, adding it to the current row. Does not advance.\n\n  Following convention, a field that hasn't had any chars appended appears as an\n  empty string, not nil.\"\n  [{:keys [field-buffer row] :as state}]\n  (assoc state\n         :field-buffer nil\n         :row (conj row (str field-buffer))))\n\n(defn- -end-row\n  \"Finalize the last field in the row. Then append the row to the collection of\n  all rows, and start a new row. Does not advance.\"\n  [state]\n  (let [{:keys [row] :as state} (-end-field state)]\n    (-> state\n        (update :rows conj row)\n        (assoc :row []))))\n\n(defn- -init-read\n  \"Prepare to process the string `data`. Advances to the first character.\"\n  [data]\n  (-advance {:chars        (seq data)\n             :field-buffer nil\n             :row          []\n             :rows         []}))\n\n(defn read-csv\n  \"Reads data from String in CSV-format.\"\n  {:arglists '([data] [data & options]) :added \"0.3.0\"}\n  [data & options]\n  (let [{:keys [separator newline] :or {separator \",\" newline :lf}} options\n        ;; convert separator from string to character\n        separator (first separator)]\n    (when-not (contains? newlines newline)\n      (throw (js/Error. newline-error-message)))\n    (loop [{:keys [char chars in-quoted-field field-buffer] :as state} (-init-read data)]\n      (if-not char\n        (:rows (-end-row state))\n        ;; NOTE: always advance or consume to avoid infinite loops\n        (recur (if in-quoted-field\n                 (if (= char \\\")\n                   (if (= (first chars) \\\")\n                     ;; pair of double quotes: use one \"escaped\" quote and drop\n                     ;; the other, staying in quoted field\n                     (-> state (-consume) (-advance))\n                     ;; one double quote: end of quoted field\n                     ;; NOTE: we expect that a separator or newline is next, but\n                     ;; don't verify. Therefore, any characters between the\n                     ;; \"closing\" double quote and the next separator or newline\n                     ;; will be appended to the current field.\n                     (-> state (dissoc :in-quoted-field) (-advance)))\n                   ;; regular character in quoted field\n                   (-consume state))\n                 (cond\n                   ;; first char in field is a quote\n                   (and (= char \\\")\n                        (not field-buffer))\n                   (-> state (assoc :in-quoted-field true) (-advance))\n\n                   (= char separator)\n                   (-> state (-end-field) (-advance))\n\n                   (and (= char \\return)\n                        (= newline :cr+lf)\n                        (= (first chars) \\newline))\n                   (-> state (-end-row) (-advance) (-advance))\n\n                   (and (= char \\newline)\n                        (= newline :lf))\n                   (-> state (-end-row) (-advance))\n\n                   :else\n                   (-consume state))))))))\n"]}